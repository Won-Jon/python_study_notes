# 函数

## 1. 函数的定义和调用

### 定义函数 (`def`)

使用 `def` 关键字开头，后接函数标识符名称和圆括号 `()`，括号内可以包含参数，最后以冒号 `:` 结尾。

```python
def function_name(parameters):
    """可选的文档字符串 (Docstring)"""
    # 函数体
    # 可以包含 return 语句
    return value
```

### 调用函数

通过函数名后加圆括号 `()` 来调用函数，括号内传入需要的参数。

```python
function_name(arguments)
```

**示例**：

```python
def greet(name):
    """这是一个向用户问好的函数"""
    print(f"Hello, {name}!")

greet("Alice")  # 调用函数，输出：Hello, Alice!
```

---

## 2. 参数传递的多种方式

Python 的函数参数非常灵活，主要有以下几种形式：

### a) 位置参数 (Positional Arguments)

最常见的参数类型，根据参数的位置顺序进行传递。

```python
def describe_pet(animal_type, pet_name):
    print(f"I have a {animal_type} named {pet_name}.")

describe_pet('hamster', 'Harry')  # 正确：I have a hamster named Harry.
describe_pet('Harry', 'hamster')  # 错误但不会报错，逻辑错误
```

### b) 关键字参数 (Keyword Arguments)

调用函数时通过 `参数名=值` 的形式传递，不受位置顺序限制。

```python
describe_pet(animal_type='hamster', pet_name='Harry')
describe_pet(pet_name='Harry', animal_type='hamster')  # 两种方式结果相同
```

### c) 默认参数 (Default Arguments)

在定义函数时为参数指定默认值，调用时可省略该参数。

```python
def describe_pet(pet_name, animal_type='dog'):  # animal_type 有默认值
    print(f"I have a {animal_type} named {pet_name}.")

describe_pet('Willie')          # I have a dog named Willie.
describe_pet('Harry', 'hamster') # I have a hamster named Harry.
```

**重要警告**：默认参数必须指向**不可变对象**！

```python
# 错误示例：使用可变对象作为默认值
def add_to_list(item, my_list=[]):  # 危险！
    my_list.append(item)
    return my_list

print(add_to_list(1))  # [1]
print(add_to_list(2))  # [1, 2] - 出乎意料！

# 正确做法：使用 None 作为默认值
def add_to_list(item, my_list=None):
    if my_list is None:
        my_list = []
    my_list.append(item)
    return my_list
```

> 在 Python 中，函数重复定义不会抛错，会覆盖之前的定义，而且这种覆盖是全局性的、永久的。调用时只执行之前定义的函数。

| 情况 | 是否必须 | 说明 |
|------|----------|------|
| **普通函数调用** | ✅ 是 | 必须先定义后调用 |
| **函数内部调用** | ⚠️ 相对宽松 | 只要在执行时已定义即可 |
| **递归函数** | ✅ 是，但特殊 | 调用自身，函数已定义 |
| **模块间调用** | ✅ 是 | 必须先导入再使用 |

> 默认参数必须指向不可变对象,因为如果指向可变对象，则函数调用时，参数会改变，导致函数执行结果不一致。

| 情况 | 做法 | 说明 |
|------|------|------|
| **默认参数** | ✅ 使用不可变对象 | 数字、字符串、元组、`None` |
| **需要可变默认值** | ✅ 使用 `None` 并在函数内创建 | `if param is None: param = []` |
| **绝对不要** | ❌ 使用可变对象作为默认值 | 列表、字典、集合等 |
| **底层原因** | 🔧 默认值只创建一次 | 所有调用共享同一个默认对象 |

### d) 可变参数 (`*args` 和 `**kwargs`)

#### `*args` - 接收任意数量的位置参数

将多个位置参数收集到一个**元组**中。

```python
def make_pizza(*toppings):
    """打印顾客点的所有配料"""
    print("Making a pizza with the following toppings:")
    for topping in toppings:
        print(f"- {topping}")

make_pizza('pepperoni')
make_pizza('mushrooms', 'green peppers', 'extra cheese')
```

#### `**kwargs` - 接收任意数量的关键字参数

将多个关键字参数收集到一个**字典**中。

```python
def build_profile(first, last, **user_info):
    """创建一个包含用户信息的字典"""
    user_info['first_name'] = first
    user_info['last_name'] = last
    return user_info

user_profile = build_profile('albert', 'einstein',
                             location='princeton',
                             field='physics')
print(user_profile)
# {'location': 'princeton', 'field': 'physics', 'first_name': 'albert', 'last_name': 'einstein'}
```

### e) 参数组合顺序规则

定义函数时，参数必须按以下顺序声明：

1. 位置参数
2. `*args` 参数
3. 关键字参数（有默认值的）
4. `**kwargs` 参数

```python
def example(a, b, *args, c=10, **kwargs):
    pass  # a, b 是位置参数，args 是可变位置参数，c 是关键字参数，kwargs 是可变关键字参数
```

---

## 3. 返回值 (`return`)

### 基本返回值

```python
def get_formatted_name(first_name, last_name):
    """返回整洁的姓名"""
    full_name = f"{first_name} {last_name}"
    return full_name.title()

musician = get_formatted_name('jimi', 'hendrix')
print(musician)  # Jimi Hendrix
```

### 返回多个值

实际上返回的是一个元组，可以通过解包获取各个值。

```python
def calculate(numbers):
    """返回一组数字的平均值和总和"""
    total = sum(numbers)
    average = total / len(numbers)
    return average, total  # 返回一个元组 (average, total)

avg, sum_total = calculate([1, 2, 3, 4, 5])  # 元组解包
print(f"Average: {avg}, Sum: {sum_total}")  # Average: 3.0, Sum: 15
```

### 无返回值函数

没有 `return` 语句或 `return` 后面没有值的函数，返回 `None`。

```python
def greet(name):
    print(f"Hello, {name}!")

result = greet('Alice')
print(result)  # None
```

---

## 4. 变量的作用域 (Scope)

### 局部变量 vs 全局变量

```python
x = 10  # 全局变量

def test_scope():
    y = 20  # 局部变量，只在函数内有效
    print(f"Inside function: x = {x}, y = {y}")  # 可以读取全局变量

test_scope()
print(f"Outside function: x = {x}")  # 可以访问全局变量
# print(y)  # 错误！y 是局部变量，外部无法访问
```

### `global` 关键字

用于在函数内部修改全局变量。

```python
x = 10

def modify_global():
    global x  # 声明要修改全局变量 x
    x = 20
    print(f"Inside function: x = {x}")

modify_global()  # Inside function: x = 20
print(f"Outside function: x = {x}")  # Outside function: x = 20
```

### `nonlocal` 关键字

用于嵌套函数中，修改外层（非全局）作用域的变量。

```python
def outer():
    count = 0
    
    def inner():
        nonlocal count  # 声明要修改外层函数的变量 count
        count += 1
        return count
    
    return inner

counter = outer()
print(counter())  # 1
print(counter())  # 2
```

---

## 5. 函数的高级特性

### Lambda 表达式（匿名函数）

用于创建小巧的、一次性的函数对象。

```python
# 传统函数定义
def square(x):
    return x ** 2

# Lambda 等价形式
square = lambda x: x ** 2

# square(5) 相当于 (lambda x: x ** 2)(5)

# 常用于排序等场景
points = [(1, 2), (3, 1), (5, -1), (0, 4)]
points_sorted = sorted(points, key=lambda point: point[1])  # 按 y 坐标排序
print(points_sorted)  # [(5, -1), (3, 1), (1, 2), (0, 4)]
```

### 函数作为参数和返回值（一等公民特性）

```python
def apply_operation(numbers, operation):
    """将操作应用于每个数字"""
    return [operation(num) for num in numbers]

def square(x):
    return x * x

def cube(x):
    return x * x * x

numbers = [1, 2, 3, 4]
print(apply_operation(numbers, square))  # [1, 4, 9, 16]
print(apply_operation(numbers, cube))    # [1, 8, 27, 64]
```

### 闭包 (Closure)

内部函数记住并访问外部函数作用域的变量，即使外部函数已经执行完毕。

```python
def make_multiplier(factor):
    """创建一个乘法器函数"""
    def multiplier(x):
        return x * factor  # 记住外部函数的 factor 变量
    return multiplier

double = make_multiplier(2)
triple = make_multiplier(3)

print(double(5))  # 10
print(triple(5))  # 15
```

#### 闭包和嵌套函数的区别

| 方面 | 嵌套函数 | 闭包 |
|------|----------|------|
| **定义** | 函数内部的函数 | 访问外部变量的嵌套函数 |
| **变量访问** | 可能访问，也可能不访问 | **必须**访问外部变量 |
| **状态保持** | 不保持状态 | **保持状态** |
| **返回值** | 通常返回计算结果 | 通常返回函数本身 |
| **内存** | 更节省内存 | 可能占用更多内存 |
| **主要用途** | 代码组织、辅助函数 | 状态保持、配置工厂、装饰器 |

### 装饰器 (Decorator) - 重点和难点

用于在不修改原函数代码的情况下，为函数添加新功能。

```python
def my_decorator(func):
    """一个简单的装饰器"""
    def wrapper():
        print("Something is happening before the function is called.")
        func()
        print("Something is happening after the function is called.")
    return wrapper

@my_decorator  # 语法糖，相当于 say_hello = my_decorator(say_hello)
def say_hello():
    print("Hello!")

say_hello()
# 输出：
# Something is happening before the function is called.
# Hello!
# Something is happening after the function is called.
```

**带参数的装饰器**：

```python
def repeat(num_times):
    """装饰器工厂，返回一个装饰器"""
    if num_times < 0:
        raise ValueError("num_times must be non-negative")
    
    def decorator_repeat(func):
        def wrapper(*args, **kwargs):
            result = None
            for _ in range(num_times):
                result = func(*args, **kwargs)
            return result
        return wrapper
    return decorator_repeat

@repeat(num_times=3) # 相当于 decorator = repeat(num_times=3) , decorator(greet)
def greet(name):
    print(f"Hello {name}")

greet("Alice")

# 输出：
# Hello Alice
# Hello Alice
# Hello Alice
```

#### 闭包和装饰器的关系

可以用这个关系来理解：

```text
闭包 ⊃ 装饰器
```

- 所有装饰器都是闭包
- 但不是所有闭包都是装饰器

| 特性 | 闭包 | 装饰器 |
|------|------|--------|
| **本质** | 内部函数访问外部变量 | 特殊的闭包应用 |
| **目的** | 记住状态、配置函数 | 增强或修改函数行为 |
| **参数** | 可以是任何类型 | 必须接收函数作为参数 |
| **返回值** | 通常是函数 | 必须是函数 |
| **语法糖** | 没有特殊语法 | 有 `@decorator` 语法 |

## 6. 类型提示 (Type Hints) - Python 3.5+

虽然不是强制性的，但类型提示可以提高代码的可读性和可维护性。

```python
from typing import List, Tuple, Dict, Optional

def process_data(
    numbers: List[int], 
    multiplier: float = 1.0
) -> Tuple[float, Optional[str]]:
    """处理数字列表，返回平均值和可能的消息"""
    if not numbers:
        return 0.0, "No numbers provided"
    
    average = sum(numbers) / len(numbers) * multiplier
    return average, None

result, message = process_data([1, 2, 3, 4], 2.0)
```

> 1. **函数名**：使用小写字母和下划线，如 `calculate_average`
> 2. **文档字符串**：为每个函数编写 docstring，说明其功能、参数和返回值
> 3. **单一职责**：一个函数只做一件事
> 4. **参数数量**：尽量避免过多参数（通常不超过 5-7 个）
> 5. **避免副作用**：函数应该主要通过返回值与外界通信，避免修改外部状态
> 6. **使用类型提示**：让代码更清晰，IDE 支持更好

## 7.其他内置函数

### 7.1. `any()` 函数

检查可迭代对象中**是否至少有一个元素为真**（True）。只要有一个为真就返回 `True`，全部为假才返回 `False`。

```python
any(iterable)
```

#### 工作原理

```python
def any(iterable):
    for element in iterable:
        if element:  # 如果元素为真
            return True
    return False  # 所有元素都为假
```

示例：

```python
# 检查列表中是否有真值
print(any([False, False, True]))   # True - 有一个True
print(any([0, "", None, []]))      # False - 所有都是假值
print(any([1, "hello", [1, 2]]))   # True - 所有都是真值

# 实用场景：检查是否有满足条件的元素
numbers = [1, 3, 5, 8, 9]
print(any(num > 7 for num in numbers))  # True - 有数字大于7

# 检查多个条件中是否至少一个为真
conditions = [False, False, True]
if any(conditions):
    print("至少一个条件满足")
```

---

### 2. `all()` 函数

检查可迭代对象中**是否所有元素都为真**。全部为真才返回 `True`，只要有一个为假就返回 `False`。

```python
all(iterable)
```

示例：

```python
def all(iterable):
    for element in iterable:
        if not element:  # 如果元素为假
            return False
    return True  # 所有元素都为真
```

示例：

```python
# 检查列表中是否所有元素都为真
print(all([True, True, True]))     # True - 所有都是True
print(all([1, "hello", [1, 2]]))   # True - 所有都是真值
print(all([1, "", [1, 2]]))        # False - 有空字符串（假值）

# 实用场景：验证所有数据是否有效
data = ["John", "25", "john@example.com"]
if all(data):  # 检查所有字段是否都已填写
    print("所有数据有效")

# 检查是否所有元素都满足条件
numbers = [10, 20, 30, 40]
print(all(num > 5 for num in numbers))  # True - 所有数字都大于5
```

---

### 3. `zip()` 函数

将**多个可迭代对象**中对应的元素"打包"成元组，返回一个迭代器。

```python
zip(iterable1, iterable2, ...)
```

示例：

```python
# 基本用法
names = ["Alice", "Bob", "Charlie"]
ages = [25, 30, 35]

zipped = zip(names, ages)
print(list(zipped))  # [('Alice', 25), ('Bob', 30), ('Charlie', 35)]

# 处理不同长度的可迭代对象
list1 = [1, 2, 3, 4]
list2 = ['a', 'b', 'c']  # 较短
result = list(zip(list1, list2))
print(result)  # [(1, 'a'), (2, 'b'), (3, 'c')] - 以短的为准

# 解压（使用 * 操作符）
pairs = [('Alice', 25), ('Bob', 30), ('Charlie', 35)]
names, ages = zip(*pairs)
print(names)  # ('Alice', 'Bob', 'Charlie')
print(ages)   # (25, 30, 35)
```

### 4. `enumerate()`函数

在迭代可迭代对象（如列表、元组、字符串等）时，**同时获取元素的索引和值**。

```python
enumerate(iterable, start=0)
```

- `iterable`: 要迭代的对象
- `start`: 起始索引值，默认为 0

返回一个**枚举对象**（迭代器），每次迭代产生一个 `(index, value)` 元组。

示例：

```python
fruits = ['apple', 'banana', 'cherry']

for index, fruit in enumerate(fruits):
    print(f"Index: {index}, Fruit: {fruit}")
```
