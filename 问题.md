def repeat(num_times):
    def decorator_repeat(func):
        def wrapper(*args, **kwargs):
            result = None  # 先初始化
            for _in range(num_times):
                result = func(*args,**kwargs)
            return result
        return wrapper
    return decorator_repeat
这段代码是否是闭包加装饰器嵌套所形成的

闭包是自定义函数吗？ 先指定相应的常数，再传入变量。还有其它应用吗？
def make_multiplier(factor):
    """创建一个乘法器函数"""
    def multiplier(x):
        return x * factor  # 记住外部函数的 factor 变量
    return multiplier

double = make_multiplier(2)
triple = make_multiplier(3)

print(double(5))  # 10
print(triple(5))  # 15

zip() 只传入一个参数是否报错？

def create_cached_function(func):
    """为函数添加缓存功能"""
    cache = {}
    def cached_version(*args):
        if args in cache:
            print(f"Cache hit for {args}")
            return cache[args]
        result = func(*args)
        cache[args] = result
        print(f"Cache miss for {args}")
        return result
    return cached_version

# 使用装饰器

@create_cached_function
def expensive_computation(x):
    return x * x  # 假设这是很耗时的计算

print(expensive_computation(5))  # Cache miss, 计算 25
print(expensive_computation(5))  # Cache hit, 直接返回 25
print(expensive_computation(3))  # Cache miss, 计算 9
