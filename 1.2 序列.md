# 序列

## 通用操作

最常用的序列类型包括：

* **列表（list）**: `[1, 2, 3]`
* **元组（tuple）**: `(1, 2, 3)`
* **字符串（str）**: `"hello"`
* **范围（range）**: `range(5)`

这些类型都支持一系列通用的操作，下面我将详细解释这些操作。

---

### 1. 索引（Indexing）

通过索引（下标）可以访问序列中的单个元素。**索引从 0 开始**，也支持**负数索引**（从右向左，从 -1 开始）。

```python
my_str = "Hello"
my_list = ['a', 'b', 'c', 'd']

print(my_str[0])    # 输出: H (第一个元素)
print(my_list[2])   # 输出: c (第三个元素)
print(my_str[-1])   # 输出: o (倒数第一个元素)
print(my_list[-2])  # 输出: c (倒数第二个元素)
```

### 2. 切片（Slicing）

通过切片可以获取序列的一个子集。语法为 `sequence[start:stop:step]`。

* `start`: 起始索引（**包含**该位置），默认为 0。
* `stop`: 结束索引（**不包含**该位置），默认为序列末尾。
* `step`: 步长，默认为 1。可以为负数，表示从右向左切片。

```python
numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

print(numbers[2:5])    # 输出: [2, 3, 4]   (索引2到5，不包括5)
print(numbers[:5])     # 输出: [0, 1, 2, 3, 4] (从开始到索引5)
print(numbers[5:])     # 输出: [5, 6, 7, 8, 9] (从索引5到结束)
print(numbers[::2])    # 输出: [0, 2, 4, 6, 8] (每隔一个取一个)
print(numbers[::-1])   # 输出: [9, 8, 7, 6, 5, 4, 3, 2, 1, 0] (反转序列)
print(numbers[5:1:-1]) # 输出: [5, 4, 3, 2] (从右向左切片)
```

### 3. 相加（Concatenation）和相乘（Multiplication）

使用 `+` 可以将**相同类型**的序列连接起来。
使用 `*` 可以将序列重复多次。

```python
list1 = [1, 2, 3]
list2 = [4, 5, 6]
tuple1 = (1, 2)
tuple2 = (3, 4)

print(list1 + list2)   # 输出: [1, 2, 3, 4, 5, 6]
print(tuple1 + tuple2) # 输出: (1, 2, 3, 4)
print(list1 * 3)       # 输出: [1, 2, 3, 1, 2, 3, 1, 2, 3]
print('_' * 10)        # 输出: __________
```

### 4. 成员检查（Membership Testing）

使用 `in` 和 `not in` 运算符可以检查一个元素是否存在于序列中。

```python
fruits = ['apple', 'banana', 'orange']
greeting = "Hello World"

print('apple' in fruits)      # 输出: True
print('pear' not in fruits)   # 输出: True
print('llo' in greeting)      # 输出: True (字符串检查子串)
```

### 5. 长度、最小值、最大值（Length, Minimum, Maximum）

使用内置函数：

* `len(sequence)`: 返回序列包含的元素个数。
* `min(sequence)`: 返回序列中最小的元素。
* `max(sequence)`: 返回序列中最大的元素。

```python
numbers = [5, 2, 8, 1, 9]
name = "Python"

print(len(numbers)) # 输出: 5
print(min(numbers)) # 输出: 1
print(max(numbers)) # 输出: 9
print(len(name))    # 输出: 6
print(min(name))    # 输出: 'P' (根据ASCII码比较)
print(max(name))    # 输出: 'y' (根据ASCII码比较)
```

### 6. 迭代（Iteration）

使用 `for` 循环可以遍历序列中的每个元素。

```python
word = "cat"
for letter in word:
    print(letter)
# 输出:
# c
# a
# t

for idx, value in enumerate(['a', 'b', 'c']):
    print(f"Index {idx} has value {value}")
# 输出:
# Index 0 has value a
# Index 1 has value b
# Index 2 has value c
```

### 7. 计数和查找（Counting and Finding Index）

虽然严格来说这是方法而非操作符，但它们是序列类型非常通用的功能。

* `sequence.count(x)`: 返回元素 `x` 在序列中出现的次数。
* `sequence.index(x)`: 返回元素 `x` 在序列中**第一次出现**的索引。如果找不到，会引发 `ValueError`。

```python
data = [1, 2, 2, 3, 2, 4, 5]

print(data.count(2))    # 输出: 3 (数字2出现了3次)
print(data.index(3))    # 输出: 3 (数字3第一次出现在索引3的位置)

# 可以在指定的起止范围内查找
print(data.index(2, 2, 5)) # 输出: 2 (在索引2到5的范围内找2)
```

---

### 总结表格

| 操作/函数 | 语法/示例 | 描述 |
| :--- | :--- | :--- |
| **索引** | `seq[i]` | 获取索引 `i` 处的元素 |
| **切片** | `seq[start:stop:step]` | 获取序列的一个子序列 |
| **相加** | `seq1 + seq2` | 连接两个序列 |
| **相乘** | `seq * n` 或 `n * seq` | 将序列重复 n 次 |
| **成员检查** | `x in seq`, `x not in seq` | 检查元素是否在序列中 |
| **长度** | `len(seq)` | 获取序列长度 |
| **最小值** | `min(seq)` | 获取序列中的最小元素 |
| **最大值** | `max(seq)` | 获取序列中的最大元素 |
| **迭代** | `for x in seq:` | 遍历序列中的每个元素 |
| **计数** | `seq.count(x)` | 计算元素 `x` 的出现次数 |
| **查找索引** | `seq.index(x)` | 查找元素 `x` 第一次出现的索引 |

### 重要区别：可变序列 vs. 不可变序列

上述操作都是“读取”操作，不会修改序列本身。要区分序列的**可变性**：

* **不可变序列（Immutable）**: **字符串（str）**、**元组（tuple）**、**范围（range）**。
  * 你不能直接通过索引或切片来修改它们的内容。
  * `my_str[0] = 'J'` 会引发 `TypeError`。

* **可变序列（Mutable）**: **列表（list）**。
  * 支持所有通用操作，**还支持通过索引和切片进行修改**。

    ```python
    my_list = [1, 2, 3, 4]
    my_list[0] = 99      # 修改索引0的元素 -> [99, 2, 3, 4]
    my_list[1:3] = [55, 66] # 修改切片 -> [99, 55, 66, 4]
    my_list[1:3] = []    # 删除 -> [99, 4]
    ```

---

好的，我们来详细讲解 Python 中的**嵌套索引**。

嵌套索引是指访问**嵌套数据结构**（如列表中的列表、字典中的列表等）中元素的操作。最常见的场景是处理多维数据，比如矩阵、表格数据等。

---

## 1. 嵌套列表（多维列表）

这是最常见的嵌套索引应用场景。

### 创建嵌套列表（二维数组/矩阵）

```python
# 一个 3x3 的矩阵
matrix = [
    [1, 2, 3],
    [4, 5, 6], 
    [7, 8, 9]
]

# 不规则嵌套列表
irregular_list = [
    [1, 2, 3],
    [4, 5],
    [6, 7, 8, 9]
]
```

### 访问单个元素

使用多个索引来访问嵌套元素：

```python
print(matrix[0])      # 输出: [1, 2, 3] (第一行)
print(matrix[0][0])   # 输出: 1 (第一行第一列)
print(matrix[1][2])   # 输出: 6 (第二行第三列)
print(matrix[2][1])   # 输出: 8 (第三行第二列)

# 对于不规则列表
print(irregular_list[2][3])  # 输出: 9 (第三行第四列)
```

### 修改嵌套元素

```python
matrix[0][0] = 100  # 修改第一行第一列的元素
print(matrix)
# 输出: [[100, 2, 3], [4, 5, 6], [7, 8, 9]]

irregular_list[1][1] = 50  # 修改第二行第二列的元素
print(irregular_list)
# 输出: [[1, 2, 3], [4, 50], [6, 7, 8, 9]]
```

### 遍历嵌套列表

#### 方法1：直接遍历

```python
# 遍历行
for row in matrix:
    print(row)
# 输出:
# [1, 2, 3]
# [4, 5, 6] 
# [7, 8, 9]

# 遍历所有元素
for row in matrix:
    for element in row:
        print(element, end=' ')
    print()  # 换行
# 输出:
# 1 2 3 
# 4 5 6
# 7 8 9
```

#### 方法2：使用索引遍历

```python
# 使用 range 和索引
for i in range(len(matrix)):
    for j in range(len(matrix[i])):
        print(f"matrix[{i}][{j}] = {matrix[i][j]}")
# 输出:
# matrix[0][0] = 1
# matrix[0][1] = 2
# matrix[0][2] = 3
# ...
```

---

## 2. 更深层次的嵌套

嵌套可以有多层，比如三维数组：

```python
# 三维数组：2个2x3的矩阵
cube = [
    [[1, 2, 3], [4, 5, 6]],    # 第一个矩阵
    [[7, 8, 9], [10, 11, 12]]  # 第二个矩阵
]

print(cube[0])        # 输出: [[1, 2, 3], [4, 5, 6]]
print(cube[0][1])     # 输出: [4, 5, 6]
print(cube[0][1][2])  # 输出: 6 (第一个矩阵的第二行第三列)
print(cube[1][0][1])  # 输出: 8 (第二个矩阵的第一行第二列)
```

---

## 3. 嵌套索引与其他数据结构的组合

### 列表嵌套字典

```python
students = [
    {"name": "Alice", "scores": [85, 92, 78]},
    {"name": "Bob", "scores": [76, 88, 95]},
    {"name": "Charlie", "scores": [90, 85, 92]}
]

# 访问 Alice 的第二个成绩
print(students[0]["scores"][1])  # 输出: 92

# 修改 Bob 的第三个成绩
students[1]["scores"][2] = 100
print(students[1]["scores"])  # 输出: [76, 88, 100]
```

### 字典嵌套列表

```python
class_data = {
    "math": [85, 76, 92, 88],
    "english": [78, 85, 90, 82], 
    "science": [92, 88, 85, 90]
}

# 访问数学课的第三个成绩
print(class_data["math"][2])  # 输出: 92

# 修改英语课的最后一个成绩
class_data["english"][-1] = 95
print(class_data["english"])  # 输出: [78, 85, 90, 95]
```

### 更复杂的嵌套结构

```python
school = {
    "classes": [
        {
            "name": "Class A",
            "students": [
                {"name": "Alice", "grades": {"math": 85, "english": 92}},
                {"name": "Bob", "grades": {"math": 76, "english": 88}}
            ]
        },
        {
            "name": "Class B", 
            "students": [
                {"name": "Charlie", "grades": {"math": 90, "english": 85}}
            ]
        }
    ]
}

# 访问 Alice 的数学成绩
alice_math = school["classes"][0]["students"][0]["grades"]["math"]
print(alice_math)  # 输出: 85

# 修改 Bob 的英语成绩
school["classes"][0]["students"][1]["grades"]["english"] = 95
```

---

## 4. 嵌套索引的切片操作

你也可以对嵌套结构进行切片：

```python
matrix = [
    [1, 2, 3, 4],
    [5, 6, 7, 8],
    [9, 10, 11, 12]
]

# 获取前两行的前两列
sub_matrix = [row[:2] for row in matrix[:2]]
print(sub_matrix)  # 输出: [[1, 2], [5, 6]]

# 或者直接切片（如果结构规则）
print(matrix[1][:2])  # 输出: [5, 6] (第二行的前两列)
```

---

## 5. 处理嵌套索引时的注意事项

### 避免索引越界

```python
matrix = [[1, 2], [3, 4]]

# 这会引发 IndexError
try:
    print(matrix[2][0])  # 只有0,1行，没有第2行
except IndexError as e:
    print(f"错误: {e}")

try:
    print(matrix[0][2])  # 第一行只有0,1列，没有第2列  
except IndexError as e:
    print(f"错误: {e}")
```

### 处理不规则嵌套结构

```python
irregular = [[1, 2], [3, 4, 5], [6]]

# 安全访问
if len(irregular) > 2 and len(irregular[2]) > 1:
    print(irregular[2][1])
else:
    print("该索引不存在")

# 使用 try-except
try:
    print(irregular[2][1])
except IndexError:
    print("索引越界")
```

---

## 6. 实用技巧

### 使用 `get()` 方法处理字典嵌套

```python
data = {"scores": [85, 92, 78]}

# 安全访问，避免 KeyError
math_score = data.get("math", [])  # 如果不存在，返回空列表
if math_score:  # 检查列表是否为空
    print(math_score[0])
else:
    print("数学成绩不存在")
```

### 使用循环处理深层嵌套

```python
def find_value(nested_structure, target_key):
    """在嵌套结构中查找特定键的值"""
    if isinstance(nested_structure, dict):
        for key, value in nested_structure.items():
            if key == target_key:
                return value
            if isinstance(value, (dict, list)):
                result = find_value(value, target_key)
                if result is not None:
                    return result
    elif isinstance(nested_structure, list):
        for item in nested_structure:
            result = find_value(item, target_key)
            if result is not None:
                return result
    return None

# 使用示例
result = find_value(school, "math")
print(result)  # 可能会找到某个数学成绩
```
